import * as React from 'react';

/**
 * –°–∏—Å—Ç–µ–º–∞ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö
 * –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –±—ã—Å—Ç—Ä—É—é –∑–∞–≥—Ä—É–∑–∫—É –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –º–µ–∂–¥—É —Å–µ—Å—Å–∏—è–º–∏
 */

// –ö–ª—é—á–∏ –¥–ª—è localStorage
const CACHE_KEYS = {
  ORDERS: 'orders_cache',
  EXPENSES: 'expenses_cache',
  PAYOUTS: 'payouts_cache',
  DEBTS: 'debts_cache',
  USERS: 'users_cache',
  LAST_UPDATE: 'last_update',
  CACHE_VERSION: 'cache_version',
  LAST_SYNC: 'last_sync',
} as const;

// –í–µ—Ä—Å–∏—è –∫—ç—à–∞ –¥–ª—è –∏–Ω–≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è—Ö
const CACHE_VERSION = '1.1.0';

// –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ –∫—ç—à–∞ (–≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö)
const CACHE_TTL = {
  ORDERS: 2 * 60 * 1000, // 2 –º–∏–Ω—É—Ç—ã (—É–º–µ–Ω—å—à–µ–Ω–æ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è)
  EXPENSES: 10 * 60 * 1000, // 10 –º–∏–Ω—É—Ç
  PAYOUTS: 5 * 60 * 1000, // 5 –º–∏–Ω—É—Ç
  DEBTS: 2 * 60 * 1000, // 2 –º–∏–Ω—É—Ç—ã
  USERS: 30 * 60 * 1000, // 30 –º–∏–Ω—É—Ç
} as const;

interface CacheItem<T> {
  data: T;
  timestamp: number;
  version: string;
}

interface CacheMetadata {
  lastUpdate: number;
  version: string;
}

/**
 * –ö–ª–∞—Å—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫—ç—à–µ–º
 */
class CacheManager {
  public isAvailable: boolean;

  constructor() {
    this.isAvailable = typeof window !== 'undefined' && 'localStorage' in window;
  }

  /**
   * –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –≤ –∫—ç—à
   */
  set<T>(key: string, data: T, ttl: number = CACHE_TTL.ORDERS): void {
    if (!this.isAvailable) return;

    try {
      const cacheItem: CacheItem<T> = {
        data,
        timestamp: Date.now(),
        version: CACHE_VERSION,
      };

      localStorage.setItem(key, JSON.stringify(cacheItem));
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
      this.updateMetadata();
    } catch (error) {
      console.warn('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –∫—ç—à:', error);
    }
  }

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫—ç—à–∞
   */
  get<T>(key: string, ttl: number = CACHE_TTL.ORDERS): T | null {
    if (!this.isAvailable) return null;

    try {
      const cached = localStorage.getItem(key);
      if (!cached) return null;

      const cacheItem: CacheItem<T> = JSON.parse(cached);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Ä—Å–∏—é –∫—ç—à–∞
      if (cacheItem.version !== CACHE_VERSION) {
        this.remove(key);
        return null;
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –∫—ç—à–∞
      const isExpired = Date.now() - cacheItem.timestamp > ttl;
      if (isExpired) {
        this.remove(key);
        return null;
      }

      return cacheItem.data;
    } catch (error) {
      console.warn('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –∏–∑ –∫—ç—à–∞:', error);
      this.remove(key);
      return null;
    }
  }

  /**
   * –£–¥–∞–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫—ç—à–∞
   */
  remove(key: string): void {
    if (!this.isAvailable) return;

    try {
      localStorage.removeItem(key);
    } catch (error) {
      console.warn('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –∫—ç—à–∞:', error);
    }
  }

  /**
   * –û—á–∏—â–∞–µ—Ç –≤–µ—Å—å –∫—ç—à
   */
  clear(): void {
    if (!this.isAvailable) return;

    try {
      Object.values(CACHE_KEYS).forEach(key => {
        localStorage.removeItem(key);
      });
    } catch (error) {
      console.warn('–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞:', error);
    }
  }

  /**
   * –û–±–Ω–æ–≤–ª—è–µ—Ç –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∫—ç—à–∞
   */
  private updateMetadata(): void {
    if (!this.isAvailable) return;

    try {
      const metadata: CacheMetadata = {
        lastUpdate: Date.now(),
        version: CACHE_VERSION,
      };

      localStorage.setItem(CACHE_KEYS.LAST_UPDATE, JSON.stringify(metadata));
      localStorage.setItem(CACHE_KEYS.CACHE_VERSION, CACHE_VERSION);
    } catch (error) {
      console.warn('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –∫—ç—à–∞:', error);
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å –∫—ç—à
   */
  shouldUpdate(key: string, ttl: number = CACHE_TTL.ORDERS): boolean {
    if (!this.isAvailable) return true;

    try {
      const cached = localStorage.getItem(key);
      if (!cached) return true;

      const cacheItem: CacheItem<any> = JSON.parse(cached);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Ä—Å–∏—é
      if (cacheItem.version !== CACHE_VERSION) return true;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏
      return Date.now() - cacheItem.timestamp > ttl;
    } catch (error) {
      return true;
    }
  }

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
   */
  getLastUpdate(): number {
    if (!this.isAvailable) return 0;

    try {
      const metadata = localStorage.getItem(CACHE_KEYS.LAST_UPDATE);
      if (!metadata) return 0;

      const parsed: CacheMetadata = JSON.parse(metadata);
      return parsed.lastUpdate;
    } catch (error) {
      return 0;
    }
  }

  /**
   * –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
   */
  setLastSync(timestamp: string): void {
    if (!this.isAvailable) return;

    try {
      localStorage.setItem(CACHE_KEYS.LAST_SYNC, timestamp);
    } catch (error) {
      console.warn('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏:', error);
    }
  }

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
   */
  getLastSync(): string | null {
    if (!this.isAvailable) return null;

    try {
      return localStorage.getItem(CACHE_KEYS.LAST_SYNC);
    } catch (error) {
      return null;
    }
  }
}

// –°–æ–∑–¥–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –∫—ç—à-–º–µ–Ω–µ–¥–∂–µ—Ä–∞
export const cacheManager = new CacheManager();

/**
 * –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π fetcher —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
 */
export const optimizedFetcher = async (url: string) => {
  const cacheKey = url.replace('/api/', '');
  
  // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫—ç—à–∞
  const cachedData = cacheManager.get(cacheKey);
  if (cachedData) {
    console.log(`üì¶ –î–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–∑ –∫—ç—à–∞: ${cacheKey}`);
    return cachedData;
  }

  // –ï—Å–ª–∏ –∫—ç—à–∞ –Ω–µ—Ç –∏–ª–∏ –æ–Ω —É—Å—Ç–∞—Ä–µ–ª, –∑–∞–≥—Ä—É–∂–∞–µ–º —Å —Å–µ—Ä–≤–µ—Ä–∞
  console.log(`üåê –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Å —Å–µ—Ä–≤–µ—Ä–∞: ${cacheKey}`);
  
  const res = await fetch(url, {
    headers: {
      'Cache-Control': 'max-age=30',
    },
  });
  
  if (!res.ok) {
    const error = new Error('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö');
    const info = await res.json();
    (error as any).info = info;
    throw error;
  }
  
  const data = await res.json();
  
  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
  cacheManager.set(cacheKey, data);
  
  return data;
};

/**
 * Fetcher –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –∏–∑–º–µ–Ω–µ–Ω–∏–π
 */
export const changesFetcher = async (url: string) => {
  const lastSync = cacheManager.getLastSync();
  const syncUrl = lastSync ? `${url}?lastSync=${lastSync}` : url;
  
  console.log(`üîÑ –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π: ${syncUrl}`);
  
  const res = await fetch(syncUrl, {
    headers: {
      'Cache-Control': 'no-cache',
    },
  });
  
  if (!res.ok) {
    const error = new Error('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π');
    const info = await res.json();
    (error as any).info = info;
    throw error;
  }
  
  const data = await res.json();
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
  if (data.timestamp) {
    cacheManager.setLastSync(data.timestamp);
  }
  
  return data;
};

/**
 * –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è SWR –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
 */
export const swrConfig = {
  revalidateOnFocus: false, // –ù–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–∏ —Ñ–æ–∫—É—Å–µ
  revalidateOnReconnect: true, // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
  dedupingInterval: 5000, // –î–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Ç–µ—á–µ–Ω–∏–µ 5 —Å–µ–∫—É–Ω–¥ (—É–º–µ–Ω—å—à–µ–Ω–æ)
  errorRetryCount: 2, // –ü–æ–≤—Ç–æ—Ä—è–µ–º –æ—à–∏–±–∫–∏ —Ç–æ–ª—å–∫–æ 2 —Ä–∞–∑–∞
  errorRetryInterval: 1000, // –ò–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É –ø–æ–≤—Ç–æ—Ä–∞–º–∏
  refreshInterval: 15000, // –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫—É–Ω–¥ (—É–º–µ–Ω—å—à–µ–Ω–æ)
  refreshWhenHidden: false, // –ù–µ –æ–±–Ω–æ–≤–ª—è–µ–º –∫–æ–≥–¥–∞ –≤–∫–ª–∞–¥–∫–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞
  refreshWhenOffline: false, // –ù–µ –æ–±–Ω–æ–≤–ª—è–µ–º –∫–æ–≥–¥–∞ –Ω–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞
  revalidateIfStale: true, // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏
  revalidateOnMount: true, // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–∏ –º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
};

/**
 * –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—ç—à–∞
 */
export const refreshCache = (key?: string) => {
  if (key) {
    cacheManager.remove(key);
  } else {
    cacheManager.clear();
  }
};

/**
 * –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∫—ç—à–∞
 */
export const getCacheStatus = () => {
  return {
    lastUpdate: cacheManager.getLastUpdate(),
    lastSync: cacheManager.getLastSync(),
    isAvailable: cacheManager.isAvailable,
    version: CACHE_VERSION,
  };
};

/**
 * –•—É–∫ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
 */
export const useCache = <T>(key: string, fetcher: () => Promise<T>, ttl?: number) => {
  const [data, setData] = React.useState<T | null>(null);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<Error | null>(null);

  React.useEffect(() => {
    const loadData = async () => {
      try {
        setLoading(true);
        setError(null);

        // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –∫—ç—à–∞
        const cached = cacheManager.get<T>(key, ttl);
        if (cached) {
          setData(cached);
          setLoading(false);
          return;
        }

        // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å —Å–µ—Ä–≤–µ—Ä–∞
        const freshData = await fetcher();
        cacheManager.set(key, freshData, ttl);
        setData(freshData);
      } catch (err) {
        setError(err as Error);
      } finally {
        setLoading(false);
      }
    };

    loadData();
  }, [key, ttl]);

  return { data, loading, error };
}; 